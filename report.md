# Сети в Linux

Настройка сетей в Linux на виртуальных машинах.


## Оглавление

   1. [Инструмент ipcalc](#part-1-инструмент-ipcalc)
   2. [Статическая маршрутизация между двумя машинами](#part-2-статическая-маршрутизация-между-двумя-машинами)
   3. [Утилита iperf3](#part-3-утилита-iperf3)
   4. [Сетевой экран](#part-4-сетевой-экран)
   5. [Статическая маршрутизация сети](#part-5-статическая-маршрутизация-сети)
   6. [Динамическая настройка IP с помощью DHCP](#part-6-динамическая-настройка-ip-с-помощью-dhcp)
   7. [NAT](#part-7-nat)
   8. [Допополнительно. Знакомство с SSH Tunnels](#part-8-дополнительно-знакомство-с-ssh-tunnels)


## Отчет

## Part 1. Инструмент **ipcalc**

### 1.1. Сети и маски
    Префиксы маски в DevOps - это набор значений, используемых для определения диапазона IP-адресов в сети. Они используются в связке с маской подсети для определения, какие IP-адреса принадлежат к одной подсети, а какие к другой.

    Маска в DevOps - это значение, используемое для определения диапазона IP-адресов в сети. Она используется вместе с IP-адресом для определения, какие адреса принадлежат к одной подсети, а какие к другой. Маска выражается в виде четырех десятичных чисел, разделенных точками, каждое из которых может принимать значение от 0 до 255.

    Диапазон IP-адресов в сети в DevOps - это группа адресов, назначенных устройствам в сети для идентификации и общения между ними. Каждый IP-адрес уникален в пределах сети, и их диапазон определяется посредством использования маски подсети.
    
1. Определим адрес сети 192.167.38.54/13 с помощью команды `ipcalc 192.167.38.54/13`. Перед этим установим утилиту ipcalc с помощью команды `sudo apt install ipcalc`.
    
    `ipcalc 192.167.38.54/13`

    ![рис.1](scrins/1.1.1.png)

2. Сети и маски

- Перевод маски 255.255.255.0 в префиксную и двоичную запись происходит следующим образом:

    Перевод в двоичную запись: каждое значение маски в десятичной форме переводится в двоичный код. Например, 255 в двоичном коде выглядит как 11111111. Получим двоичный код маски: 11111111.11111111.11111111.00000000

    Перевод в префиксную запись: количество единиц в двоичном коде маски указывает на длину префикса. В данном случае, количество единиц равно 24, что означает, что префикс 255.255.255.0 в десятичной форме может быть записан как /24.
   
    `ipcalc 192.167.38.54/255.255.255.0`

    ![рис.2](scrins/1.1.2.png)
    
- Перевод маски /15 в обычную и двоичную формы происходит следующим образом:

    Перевод в обычную форму: каждый бит в маске может быть либо единицей (1), либо нулем (0). Число /15 указывает на количество единиц в маске. Таким образом, маска /15 в обычной форме может быть записана как 255.254.0.0

    Перевод в двоичную форму: каждое значение в обычной форме переводится в двоичный код. Например, 255 в двоичном коде выглядит как 11111111. Получим двоичный код маски: 11111111.11111110.00000000.00000000.

    `ipcalc 192.167.38.54/15`

    ![рис.3](scrins/1.1.3.png)

- Перевод 11111111.11111111.11111111.11110000 в обычную и префиксную форму маски происходит следующим образом:

    Перевод в обычную форму: данное двоичное представление маски соответствует значению 255.255.255.240

    Перевод в префиксную форму: количество единиц в маске определяет длину префикса. Таким образом, длина префикса для данной маски равна 28, то есть /28.

    `ipcalc 192.167.38.54/28`

    ![рис.4](scrins/1.1.4.png)

Минимальный и максимальный хосты в сети нужны для разделения IP-адресов в подсети на две части: одну для адресов устройств в сети и другую для адресов шлюзов или специальных адресов.

Минимальный хост - это первый доступный для использования IP-адрес в подсети, который может быть присвоен устройству в сети.

Максимальный хост - это последний доступный для использования IP-адрес в подсети, который может быть присвоен устройству в сети.

Использование минимального и максимального хостов помогает системам управления сетями лучше организовывать и администрировать адресацию IP в сети.

Минимальный и максимальный хост в сети 12.167.38.4 
- при маске /8
   
    `ipcalc 12.167.38.4/8`

![рис.5](scrins/1.1.5.png)

- при маске 11111111.11111111.00000000.00000000

    `ipcalc 12.167.38.4/16`

![рис.6](scrins/1.1.6.png)

- при маске 255.255.254.0

    `ipcalc 12.167.38.4/255.255.254.0`

![рис.7](scrins/1.1.7.png)

- при маске /4

    `ipcalc 12.167.38.4/4`

![рис.8](scrins/1.1.8.png)

### 1.2. localhost

    Loopback на localhost - это специальный IP-адрес (127.0.0.1), используемый для обращения к собственному компьютеру. Он используется для тестирования сетевых услуг и приложений на локальном компьютере, а также для установления сетевых соединений между различными приложениями на одном компьютере. Он также известен как loopback-интерфейс.

1. Определим, можно ли обратиться к приложению, работающему на localhost, со следующими IP:

- 194.34.23.100 - нельзя
![рис.9](scrins/1.2.1.png)

- 127.0.0.2 - можно
![рис.10](scrins/1.2.2.png)

- 127.1.0.1 - можно
![рис.11](scrins/1.2.3.png)

- 128.0.0.1 - нельзя
![рис.12](scrins/1.2.4.png)

### 1.3. Диапазоны и сегменты сетей

1. Определим, какие из перечисленных IP можно использовать в качестве публичного, а какие только в качестве частных: 10.0.0.45, 134.43.0.2, 192.168.4.2, 172.20.250.4, 172.0.2.1, 192.172.0.1, 172.68.0.2, 172.16.255.255, 10.10.10.10, 192.169.168.1
    
    IP-адреса можно разделить на две категории: публичные и частные. Публичные IP-адреса могут быть использованы для подключения к Интернету, тогда как частные IP-адреса используются только внутри частных сетей.
    

`в качестве частного:`

 10.0.0.45
 ![рис.13](scrins/1.3.1.png)

 192.168.4.2
 ![рис.15](scrins/1.3.3.png)

 172.20.250.4
 ![рис.16](scrins/1.3.4.png)

 172.16.255.255
 ![рис.20](scrins/1.3.8.png)

 10.10.10.10
 ![рис.21](scrins/1.3.9.png)

`в качестве публичного:`

 134.43.0.2
 ![рис.14](scrins/1.3.2.png)

  172.0.2.1
 ![рис.17](scrins/1.3.5.png)

  192.172.0.1
 ![рис.18](scrins/1.3.6.png)

  172.68.0.2
 ![рис.19](scrins/1.3.7.png)

  192.169.168.1
 ![рис.22](scrins/1.3.10.png)

2. Определим, какие из перечисленных ниже IP адресов шлюза возможны у сети 10.10.0.0/18: 10.0.0.1, 10.10.0.2, 10.10.10.10, 10.10.100.1, 10.10.1.255

![рис.23](scrins/1.3.11.png)

    У сети 10.10.0.0/18 возможны данные IP адреса шлюза: 10.10.0.2, 10.10.10.10, 10.10.1.255; смотрим диапазон между 'Hostmin' и 'Hostmax'


#### [Вернуться к оглавлению](#linux-network)

## Part 2. Статическая маршрутизация между двумя машинами

Поднимаем две виртуальные машины ws1 и ws2

1. С помощью команды `ip a` смотрим существующие сетевые интерфейсы

![рис.24](scrins/2.0.1.png)
![рис.25](scrins/2.0.2.png)

2. Описываем сетевой интерфейс, соответствующий внутренней сети, на обеих машинах и задаем следующие адреса и маски командой `sudo vim /etc/netplan/*.yaml` : 

ws1 - 192.168.100.10, маска /16
![рис.26](scrins/2.0.3.png)

ws2 - 172.24.116.8, маска /12
![рис.27](scrins/2.0.4.png)

3. Выполняем команду `sudo netplan apply` и `sudo netplan try` для перезапуска сервиса сети  

- для ws1
![рис.28](scrins/2.0.5.png)

- для ws2
![рис.29](scrins/2.0.6.png)

И проверяем что настройки применились с помощью команды `ip a`:

* ws1  

![рис.30](scrins/2.0.7.png) 

* ws2

![рис.31](scrins/2.0.8.png)
 

### 2.1. Добавление статического маршрута вручную

"Пропинговать соединение" означает отправлять сетевые пакеты для проверки доступности удаленной машины или сетевого устройства. Это может быть использовано, чтобы определить, работает ли сетевое соединение между двумя машинами, или если одна из машин недоступна, по какой причине. 

Добавим статистический маршрут при помощи команды `ip r add` и пропингуем соединение между машинами:

* ws1:

`sudo ip r add 172.24.116.8 dev enp0s8`

`ping 172.24.116.8`
![рис.32](scrins/2.1.1.png)

* ws2:

`sudo ip r add 192.168.100.10 dev enp0s8`

`ping 192.168.100.10`
![рис.33](scrins/2.1.2.png)


#### 2.2. Добавление статического маршрута с сохранением

Добавим статический маршрут от одной машины до другой с помощью файла *etc/netplan/00-installer-config.yaml*, перезапустим сервер сети и пропингуем соединение между машинами:

![рис.34](scrins/2.2.1.png)

![рис.35](scrins/2.2.2.png)

## Part 3. Утилита **iperf3**

- Устанавливаем iperf3

#### 3.1. Скорость соединения
##### Перевести и записать в отчёт: 8 Mbps в MB/s, 100 MB/s в Kbps, 1 Gbps в Mbps

- 8 Mbps = 1 MB/s
- 100 MB/s = 819200 Kbps
- 1 Gbps = 1024 Mbps

#### 3.2. Утилита **iperf3**
##### Измерить скорость соединения между ws1 и ws2

Для измерения скорости присвоим WS1 роль клиента с помощью команды iperf3 -c [адрес сервера], а WS2 роль сервера с помощью команды iperf3 -s.

* ws1:
`iperf3 -c 172.24.116.8`
* ws2:
`iperf3 -s`

![рис.36](scrins/3.2.1.png)

![рис.37](scrins/3.2.2.png)


## Part 4. Сетевой экран

#### 4.1. Утилита **iptables**

1. Создаем файл /etc/firewall.sh на обеих виртуальных машинах командой `sudo touch /etc/firewall.sh`.
2. Открываем его командой `sudo nano /etc/firewall.sh` и редактируем:
  - удаляем все правила из таблицы filter командами `iptables -F` и `iptables -X`
  - открываем на машинах доступ для портов 22 и 80 командами `iptables -A INPUT -p tcp --dport 22 -j ACCEPT` и `iptables -A INPUT -p tcp --dport 80 -j ACCEPT`
    * ws1 - сначала запрещаем echo-reply, потом разрешаем

![рис.38](scrins/4.1.1.png)

    * ws2 - сначара разрешаем echo-reply, потом запрещаем

![рис.39](scrins/4.1.2.png)

  - Разница между стратегиями для первой и второй машины заключается в последовательности вызова команд. В обоих случаях последовательно записаны два взаимоисключающих правила, поэтому приоритет будет у того, которое стоит раньше, а другое будет игнорироваться.

  3. Запускаем этот файл на обеих машинах с помощью команды `sudo chmod +x /etc/firewall.sh && sudo sh /etc/firewall.sh`
  - ws1\
 ![рис.40](scrins/4.3.1.png)
  - ws2\
 ![рис.41](scrins/4.3.2.png)

 4. Пингуем и проверяем, какая из машин не пингуется.
  - ws1: пингуем вторую машину `ping -c 5 172.24.116.8` - пингуется
 ![рис.42](scrins/4.4.1.png)
  - ws2: пингуем первую машину `ping -c 5 192.168.100.10` - не пингуется
 ![рис.43](scrins/4.4.2.png)
 5. Устанавливаем nmap командой `sudo apt install nmap` на вторую машину. Запускаем команду `nmap 192.168.100.10`.
 ![рис.44](scrins/4.5.1.png)

 ## Part 5. Статическая маршрутизация сети

Сеть:

 ![рис.45](scrins/5.0.1.png)

#### 5.1. Настройка адресов машин

В VirtualBox создаем 5 новых виртуальных машин. В настройках всех виртуальных машин включаем внутренюю сеть. 
ПКМ - Настроить - Сеть - Адаптер 2. Ставим галочку в строке "Включить сетевой адаптер" и выбираем Тип подключения - Внутренняя сеть.

 ![рис.45](scrins/5.1.1.png)

В настройках виртуальных машин r1 и r2 дополнительно включаем внутренюю сеть на Адаптере 3.

 ![рис.45](scrins/5.1.2.png)

 Вносим настройки в конфигурационные файлы *etc/netplan/00-installer-config.yaml* для каждой машины с помощью команды `sudo vim /etc/netplan/00-installer-config.yaml` и применяем настройки с помощью команды `sudo netplan apply`:

![рис.46](scrins/5.1.3.png)

![рис.47](scrins/5.1.4.png)

![рис.48](scrins/5.1.5.png)

![рис.49](scrins/5.1.6.png)

![рис.50](scrins/5.1.7.png)

Проверяем настройки сети с помощью команды `ip -4 a`:

![рис.51](scrins/5.1.8.png)

![рис.55](scrins/5.1.12.png)

![рис.52](scrins/5.1.9.png)

![рис.53](scrins/5.1.10.png)

![рис.54](scrins/5.1.11.png)

Пропингуем r1 c ws11 и наоборот:

![рис.58](scrins/5.1.15.png)

![рис.59](scrins/5.1.16.png)

Пропингуем ws21 c ws22 и наоборот:

![рис.56](scrins/5.1.13.png)

![рис.57](scrins/5.1.14.png)

#### 5.2. Включение переадресации IP-адресов

Включим переадресации IP-адресов на роутерах с помощью команды `sudo sysctl -w net.ipv4.ip_forward=1`:

![рис.60](scrins/5.2.1.png)

![рис.61](scrins/5.2.2.png)

Откроем файл sysctl.conf с помощью команды `sudo vim /etc/sysctl.conf` и раскомментируем строку `net.ipv4.ip_forward = 1`:

![рис.62](scrins/5.2.3.png)

![рис.63](scrins/5.2.4.png)

#### 5.3. Установка маршрута по умолчанию

Настроим маршрут по-умолчанию (шлюз) для рабочих станций. Для этого добавим dafaut перед IP роутера в файлe конфигураций.

- ws11

![рис.64](scrins/5.3.1.png)

- ws21

![рис.65](scrins/5.3.2.png)

- ws22

![рис.66](scrins/5.3.3.png)

Перезапустим сервис сети и вызовем команду `ip r`:

![рис.67](scrins/5.3.4.png)

![рис.68](scrins/5.3.5.png)

![рис.69](scrins/5.3.6.png)

Пропингуем с ws11 роутер r2 и покажем на r2, что пинг доходит с помощью команды `tcpdump -tn -i eth1`:

![рис.70](scrins/5.3.7.png)

![рис.71](scrins/5.3.8.png)

#### 5.4. Добавление статических маршрутов

Добавим в роутеры r1 и r2 статические маршруты в конфигурационные файлы *etc/netplan/00-installer-config.yaml* для каждой машины с помощью команды `sudo vim /etc/netplan/00-installer-config.yaml` и применим настройки с помощью команды `sudo netplan apply`:

![рис.72](scrins/5.4.1.png)

Вызовем команду `ip r` и покажем таблицы с маршрутами на обоих роутерах. 

![рис.73](scrins/5.4.2.png)

На ws11 запустим команду `ip r list 10.10.0.0/[маска сети]` и `ip r list 0.0.0.0/0`:

![рис.74](scrins/5.4.3.png)

Для адреса 10.10.0.0/18 был выбран маршрут, отличный от 0.0.0.0/0, поскольку он является адресом сети и доступен без шлюза.

#### 5.5. Построение списка маршрутизаторов

- Устанавливаем утилиту `traceroute` командой `sudo apt install traceroute`.

Запускаем одновременно команды `traceroute 10.20.0.10` на ws11 для построения списка маршрутизаторов на пути от ws11 до ws21 и `sudo tcpdump -tnv -i eth0` на r1 для отслеживания пакетов.

![рис.75](scrins/5.5.1.png)
![рис.76](scrins/5.5.2.png)

Расшифровка флагов tcpdump:
#### -t Не отображает метку времени в каждой строке.
#### -n Отображает IP-адрес вместо имени хоста.
#### -v Вывод подробной информации (TTL («время жизни»); ID; общая длина заголовка, а также его параметры; производит проверку контрольных сумм IP и ICMP-заголовков)
#### -i Указывает на то, какой сетевой интерфейс будет использоваться для захвата пакетов.

- Traceroute — это утилита, которая позволяет проследить маршрут следования данных до удалённого адресата в сетях TCP/IP. Команда traceroute использует UDP пакеты. Она отправляет пакет с TTL=1 и смотрит адрес ответившего узла, дальше TTL=2, TTL=3 и так пока не достигнет цели. Каждый раз отправляется по три пакета и для каждого из них измеряется время прохождения. Пакет отправляется на случайный порт, который, скорее всего, не занят. Когда утилита traceroute получает сообщение от целевого узла о том, что порт недоступен трассировка считается завершенной.

#### 5.6. Использование протокола **ICMP** при маршрутизации

Запуск на r1 перехвата сетевого трафика, проходящего через eth0 с помощью команды `sudo tcpdump -n -i eth0 icmp` и пинг с ws11 несуществующего IP `ping -c 1 10.30.0.111`:

![рис.77](scrins/5.6.1.png)
![рис.78](scrins/5.6.2.png)

## Part 6. Динамическая настройка IP с помощью DHCP

##### Для r2 настроим в файле */etc/dhcp/dhcpd.conf* конфигурацию службы **DHCP**:
##### 1) указажем адрес маршрутизатора по-умолчанию, DNS-сервер и адрес внутренней сети.

Скачаем isc-dhcp-server командой `sudo apt install isc-dhcp-server`.

1. Настроим конфигурацию службы DHCP в файле `/etc/dhcp/dhcpd.conf` с помощью команды `sudo nano /etc/dhcp/dhcpd.conf` на машине r2. 
Укажем адрес маршрутизатора по-умолчанию, DNS-сервер и адрес внутренней сети.

Пример файла для r2:
```shell
subnet 10.100.0.0 netmask 255.255.0.0 {}

subnet 10.20.0.0 netmask 255.255.255.192
{
    range 10.20.0.2 10.20.0.50;
    option routers 10.20.0.1;
    option domain-name-servers 10.20.0.1;
}
```

![рис.79](scrins/6.1.png)

2. В файле resolv.conf пропишем `nameserver 8.8.8.8` с помощью команды `sudo nano /etc/resolv.conf` на машине r2:

![рис.80](scrins/6.2.png)

3. Перезагрузим службу **DHCP** с помощью команды `systemctl restart isc-dhcp-server` на машине r2:

![рис.81](scrins/6.3.png)

5. Перезагрузим машину ws21 с помощью команды `sudo reboot` и с помощью команды `ip a` покажем, что она получила адрес:

![рис.82](scrins/6.4.png)

6. Пропингуем ws22 с ws21:

![рис.83](scrins/6.5.png)

7.  Указажем MAC адрес у ws11, для этого в *etc/netplan/00-installer-config.yaml* надо добавить строки: `macaddress: 10:10:10:10:10:BA`, `dhcp4: true`

![рис.84](scrins/6.6.png)
![рис.85](scrins/6.7.png)

##### Для r1 настроим аналогично r2, но сделать выдачу адресов с жесткой привязкой к MAC-адресу (ws11).

8. Настроим конфигурацию службы DHCP в файле `/etc/dhcp/dhcpd.conf` на машине r1.


![рис.84](scrins/6.8.png)
![рис.89](scrins/6.9.png)

 В файле resolv.conf пропишем `nameserver 8.8.8.8` с помощью команды `sudo nano /etc/resolv.conf` на машине r1:

![рис.90](scrins/6.10.png)

 Перезагрузим службу **DHCP** с помощью команды `systemctl restart isc-dhcp-server` на машине r2:

![рис.91](scrins/6.11.png)

 Перезагрузим машину ws21 с помощью команды `sudo reboot` и с помощью команды `ip a` покажем, что она получила адрес:

![рис.92](scrins/6.12.png)

- Запросим с ws21 обновление ip-адреса
  * сначала вводим команду `sudo dhclient -r eth0` - этой командой мы очищаем ip адрес у порта, проверяем это командой `ip a`

  ![рис.93](scrins/6.13.png)

  ![рис.94](scrins/6.14.png)

Опции **DHCP** сервера, которыми пользовались:

subnet 10.20.0.0 netmask 255.255.255.192 {
range 10.20.0.2 10.20.0.50; - диапазон доступных IP адресов
option routers 10.20.0.1; - адрес шлюза маршрутизатора
option domain-name-servers 10.20.0.1; - IP адресс DNS-сервера
}

## Part 7. **NAT**
Скачаем isc-dhcp-server с помощью команды `sudo apt install apache2` на машины ws22 и r1. Перед этим в настройках VirtualBox на машине ws22 временно выключим адаптер 2, чтобы появился интернет. Узнать наличие интернета можно с помощью команды `ping ya.ru`.

1. На машинах ws22 и r1 в файле */etc/apache2/ports.conf* изменим строку `Listen 80` на `Listen 0.0.0.0:80` с помощью команды `sudo nano /etc/apache2/ports.conf`:

  ![рис.95](scrins/7.1.png)

2. Запустить веб-сервер Apache командой `service apache2 start` на ws22 и r1
- В отчёт поместить скрины с вызовом и выводом использованной команды.

  ![рис.96](scrins/7.2.png)

  ![рис.97](scrins/7.3.png)

3. Hа r2 создаем файл /etc/firewall.sh командой `sudo touch /etc/firewall.sh`. Открываем его и добавляем следующие правила:
##### 1) Удаление правил в таблице filter - `iptables -F`
##### 2) Удаление правил в таблице "NAT" - `iptables -F -t nat`
##### 3) Отбрасывать все маршрутизируемые пакеты - `iptables --policy FORWARD DROP`

  ![рис.98](scrins/7.4.png)

- Запускаем файл командой `sudo sh /etc/firewall.sh`
- Пингуем ws22 и r1 (При запуске файла с этими правилами, ws22 не должна "пинговаться" с r1)

  ![рис.99](scrins/7.5.png)

  4. Разрешаем маршрутизацию всех пакетов протокола ICMP, добавляя строчку `iptables -A FORWARD -p icmp -j ACCEPT` в файл `/etc/firewall.sh`

  ![рис.100](scrins/7.6.png)

- Cнова запускаем файл командой `sudo sh /etc/firewall.sh`

- Пингуем ws22 и r1 - пингуется
  ![рис.101](scrins/7.7.png)

5. Включаем SNAT, а именно маскирование всех локальных ip из локальной сети, находящейся за r2 (по обозначениям из Части 5 - сеть 10.20.0.0). 
Включаем DNAT на 8080 порт машины r2 и добавляем к веб-серверу Apache, запущенному на ws22, доступ извне сети
  ![рис.102](scrins/7.9.png)

6. Запускаем новые правила командой `sudo chmod +x /etc/firewall.sh && sudo sh /etc/firewall.sh`.

- Проверяем соединение TCP для SNAT, для этого с ws22 подключаемся к серверу Apache на r1 командой `telnet 10.100.0.11 80`\
- Проверияем соединение по TCP для DNAT, для этого с r1 подключаемся к серверу Apache на ws22 командой `telnet 10.20.0.20 8080` (обращаться по адресу r2 и порту 8080)\

  ![рис.103](scrins/7.8.png)

## Part 8. Дополнительно. Знакомство с **SSH Tunnels**

1. Запуск веб-сервера **Apache** на ws22 только на localhost:
* На машине ws22 откроем файл `/etc/apache2/ports.conf` с помощью команды `sudo nano /etc/apache2/ports.conf`. Изменим строку `Listen 80` на `Listen localhost:80`.
* Запустим веб-сервер Apache с помощью команды `service apache2 start`.

  ![рис.104](scrins/8.1.png)

  ![рис.105](scrins/8.2.png)

* В VirtualBox проборосим порты на ws22, ws21 и ws11.

  ![рис.108](scrins/8.2.1.png)

  ![рис.109](scrins/8.2.2.png)

  ![рис.110](scrins/8.2.3.png)

  2. Воспользуемся *Local TCP forwarding* с ws21 до ws22, чтобы получить доступ к веб-серверу на ws22 с ws21 - для этого ввеедём команду `ssh -L 2525:localhost:80 10.20.0.20` на ws21\

  ![рис.106](scrins/8.3.png)

  3. Воспользуемся *Remote TCP forwarding* c ws11 до ws22, чтобы получить доступ к веб-серверу на ws22 с ws11 - для этого на ws11 введём команду `ssh -R 5555:localhost:80 10.20.0.20`\

  ![рис.107](scrins/8.4.png)

4. Для проверки, сработало ли подключение в обоих предыдущих пунктах, вводили на ws11 и на ws21 `telnet 127.0.0.1 2222`